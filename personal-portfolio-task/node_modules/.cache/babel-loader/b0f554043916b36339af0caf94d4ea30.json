{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSelectionRange = getSelectionRange;\nexports.hasSelectionSupport = hasSelectionSupport;\nexports.setSelectionRange = setSelectionRange;\n\nvar _isElementType = require(\"../misc/isElementType\"); // https://github.com/jsdom/jsdom/blob/c2fb8ff94917a4d45e2398543f5dd2a8fed0bdab/lib/jsdom/living/nodes/HTMLInputElement-impl.js#L45\n\n\nvar selectionSupportType;\n\n(function (selectionSupportType) {\n  selectionSupportType[\"text\"] = \"text\";\n  selectionSupportType[\"search\"] = \"search\";\n  selectionSupportType[\"url\"] = \"url\";\n  selectionSupportType[\"tel\"] = \"tel\";\n  selectionSupportType[\"password\"] = \"password\";\n})(selectionSupportType || (selectionSupportType = {}));\n\nconst InputSelection = Symbol('inputSelection');\n\nfunction hasSelectionSupport(element) {\n  return (0, _isElementType.isElementType)(element, 'textarea') || (0, _isElementType.isElementType)(element, 'input') && Boolean(selectionSupportType[element.type]);\n}\n\nfunction getSelectionRange(element) {\n  if (hasSelectionSupport(element)) {\n    return {\n      selectionStart: element.selectionStart,\n      selectionEnd: element.selectionEnd\n    };\n  }\n\n  if ((0, _isElementType.isElementType)(element, 'input')) {\n    var _InputSelection;\n\n    return (_InputSelection = element[InputSelection]) != null ? _InputSelection : {\n      selectionStart: null,\n      selectionEnd: null\n    };\n  }\n\n  const selection = element.ownerDocument.getSelection(); // there should be no editing if the focusNode is outside of element\n  // TODO: properly handle selection ranges\n\n  if (selection != null && selection.rangeCount && element.contains(selection.focusNode)) {\n    const range = selection.getRangeAt(0);\n    return {\n      selectionStart: range.startOffset,\n      selectionEnd: range.endOffset\n    };\n  } else {\n    return {\n      selectionStart: null,\n      selectionEnd: null\n    };\n  }\n}\n\nfunction setSelectionRange(element, newSelectionStart, newSelectionEnd) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = getSelectionRange(element);\n\n  if (selectionStart === newSelectionStart && selectionEnd === newSelectionEnd) {\n    return;\n  }\n\n  if (hasSelectionSupport(element)) {\n    element.setSelectionRange(newSelectionStart, newSelectionEnd);\n  }\n\n  if ((0, _isElementType.isElementType)(element, 'input')) {\n    ;\n    element[InputSelection] = {\n      selectionStart: newSelectionStart,\n      selectionEnd: newSelectionEnd\n    };\n  } // Moving the selection inside <input> or <textarea> does not alter the document Selection.\n\n\n  if ((0, _isElementType.isElementType)(element, 'input') || (0, _isElementType.isElementType)(element, 'textarea')) {\n    return;\n  }\n\n  const range = element.ownerDocument.createRange();\n  range.selectNodeContents(element); // istanbul ignore else\n\n  if (element.firstChild) {\n    range.setStart(element.firstChild, newSelectionStart);\n    range.setEnd(element.firstChild, newSelectionEnd);\n  }\n\n  const selection = element.ownerDocument.getSelection(); // istanbul ignore else\n\n  if (selection) {\n    selection.removeAllRanges();\n    selection.addRange(range);\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","getSelectionRange","hasSelectionSupport","setSelectionRange","_isElementType","require","selectionSupportType","InputSelection","Symbol","element","isElementType","Boolean","type","selectionStart","selectionEnd","_InputSelection","selection","ownerDocument","getSelection","rangeCount","contains","focusNode","range","getRangeAt","startOffset","endOffset","newSelectionStart","newSelectionEnd","createRange","selectNodeContents","firstChild","setStart","setEnd","removeAllRanges","addRange"],"sources":["E:/SimpleReactProject/personal-portfolio-task/node_modules/@testing-library/user-event/dist/utils/edit/selectionRange.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSelectionRange = getSelectionRange;\nexports.hasSelectionSupport = hasSelectionSupport;\nexports.setSelectionRange = setSelectionRange;\n\nvar _isElementType = require(\"../misc/isElementType\");\n\n// https://github.com/jsdom/jsdom/blob/c2fb8ff94917a4d45e2398543f5dd2a8fed0bdab/lib/jsdom/living/nodes/HTMLInputElement-impl.js#L45\nvar selectionSupportType;\n\n(function (selectionSupportType) {\n  selectionSupportType[\"text\"] = \"text\";\n  selectionSupportType[\"search\"] = \"search\";\n  selectionSupportType[\"url\"] = \"url\";\n  selectionSupportType[\"tel\"] = \"tel\";\n  selectionSupportType[\"password\"] = \"password\";\n})(selectionSupportType || (selectionSupportType = {}));\n\nconst InputSelection = Symbol('inputSelection');\n\nfunction hasSelectionSupport(element) {\n  return (0, _isElementType.isElementType)(element, 'textarea') || (0, _isElementType.isElementType)(element, 'input') && Boolean(selectionSupportType[element.type]);\n}\n\nfunction getSelectionRange(element) {\n  if (hasSelectionSupport(element)) {\n    return {\n      selectionStart: element.selectionStart,\n      selectionEnd: element.selectionEnd\n    };\n  }\n\n  if ((0, _isElementType.isElementType)(element, 'input')) {\n    var _InputSelection;\n\n    return (_InputSelection = element[InputSelection]) != null ? _InputSelection : {\n      selectionStart: null,\n      selectionEnd: null\n    };\n  }\n\n  const selection = element.ownerDocument.getSelection(); // there should be no editing if the focusNode is outside of element\n  // TODO: properly handle selection ranges\n\n  if (selection != null && selection.rangeCount && element.contains(selection.focusNode)) {\n    const range = selection.getRangeAt(0);\n    return {\n      selectionStart: range.startOffset,\n      selectionEnd: range.endOffset\n    };\n  } else {\n    return {\n      selectionStart: null,\n      selectionEnd: null\n    };\n  }\n}\n\nfunction setSelectionRange(element, newSelectionStart, newSelectionEnd) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = getSelectionRange(element);\n\n  if (selectionStart === newSelectionStart && selectionEnd === newSelectionEnd) {\n    return;\n  }\n\n  if (hasSelectionSupport(element)) {\n    element.setSelectionRange(newSelectionStart, newSelectionEnd);\n  }\n\n  if ((0, _isElementType.isElementType)(element, 'input')) {\n    ;\n    element[InputSelection] = {\n      selectionStart: newSelectionStart,\n      selectionEnd: newSelectionEnd\n    };\n  } // Moving the selection inside <input> or <textarea> does not alter the document Selection.\n\n\n  if ((0, _isElementType.isElementType)(element, 'input') || (0, _isElementType.isElementType)(element, 'textarea')) {\n    return;\n  }\n\n  const range = element.ownerDocument.createRange();\n  range.selectNodeContents(element); // istanbul ignore else\n\n  if (element.firstChild) {\n    range.setStart(element.firstChild, newSelectionStart);\n    range.setEnd(element.firstChild, newSelectionEnd);\n  }\n\n  const selection = element.ownerDocument.getSelection(); // istanbul ignore else\n\n  if (selection) {\n    selection.removeAllRanges();\n    selection.addRange(range);\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}